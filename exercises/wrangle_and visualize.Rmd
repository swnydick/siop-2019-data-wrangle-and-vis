---
title: "Data: Wrangle and Display it With Relative Ease. "
author: ""
date: ""
output:
  html_document:
    theme: lumen
    toc: yes
  word_document:
    toc: yes
  pdf_document:
    toc: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(out.width='1600px', out.height = '900px', dpi=200)
library(knitr)
hook_output <- knit_hooks$get("output")
knit_hooks$set(output = function(x, options) {
  lines <- options$output.lines
  if (is.null(lines)) {
    return(hook_output(x, options))  # pass to default hook
  }
  x <- unlist(strsplit(x, "\n"))
  more <- "..."
  if (length(lines)==1) {        # first n lines
    if (length(x) > lines) {
      # truncate the output, but add ....
      x <- c(head(x, lines), more)
    }
  } else {
    x <- c(more, x[lines], more)
  }
  # paste these lines together
  x <- paste(c(x, ""), collapse = "\n")
  hook_output(x, options)
})
```

</br> 

## Data Cleaning

In this tutorial, we will be taking in two data sets from a fictional company, 
one being data on the employees' dempographics and the other is some fictional test scores.
We will be cleaning and reformatting them to make them usable, 
joining them together, and producing some graphics from them. 
Happily, all of this is actually pretty easy in R.

</br>

## Dependencies and setup

Make sure you have the following packages installed
* `openxlsx`
* `reshape2`
* `dplyr`
* `magrittr`
* `ggplot2`
* `ggthemes`
* `roperators`



I've attached an installation script that you can run to make sure the packages are all there:

```{r eval = FALSE}
pkgs <- c("openxlsx", "reshape2", "dplyr", "magrittr", "ggplot2","ggthemes", "roperators")

# Hackfix tip: 
# Opening the CRAN mirror in a browser can help with some restricted networks
utils::browseURL("http://cran.stat.auckland.ac.nz/")
utils::browseURL("https://meta.wikimedia.org/wiki/List_of_countries_by_regional_classification")

# Another hackfix for restricted networks.... just in case
httr::set_config(httr::config( ssl_verifypeer = 0L ))

for (package in pkgs){
  if(package %in% rownames(installed.packages()) == FALSE)
    # Try will attempt to do what is in parentheses, but won't die if it doesn't work
    try(install.packages(package, repos = "http://cran.stat.auckland.ac.nz/"), silent = TRUE)
}

```

 </br>
 
### Load your required packages 

```{r libs, message=FALSE}
require(openxlsx)
require(reshape2)
require(dplyr)
require(magrittr)
require(ggplot2)
require(ggthemes)
require(roperators)

```
</br>

### Load The Data

In our data folder, there are two datasets, a csv called employee_data.csv and 
an excel workbook called survey_results.xlsx


To read in the csv data, we can use base R's `read.csv` function, which is the same as
`read.table`, which you might see in other scripts, only with different default arguments. 
What's nice aboput data stored in csv files is that because they're just plain-text
flatfiles, they can be opened in any program or programming language. 



**The following code reads:**


* Create a variable called employees


* Into that value place the output of `read.csv()`


* ...Where `read.csv()` is going to go out one folder (../) and then look for `employee_data.csv` in `data`


* And finally, don't turn text variables into factors automatically! 

```{r read_csv}
employees <- read.csv("../data/employee_data.csv", stringsAsFactors = FALSE)
```


Excel's files are a little trickier to read in which is why we loaded the `openxlsx` 
package to handle it. There are other, older packages to read in .xlsx doccuments, 
however, they often have difficult Java dependencies, hence we prefer `openxlsx`

```{r read_xlsx}
survey <- read.xlsx("../data/survey_results.xlsx")
```



## Inspect The Data

Now that our data has been read into R as `dataframe`s (which are just glorified 
lists of vectors that are all the same length), we can inspect it. If you're in 
`RStudio` you can go to the environment pane (usually top-right) and click on the
names of either dataframe to open a preview of it. 

We can also take a quick look at the data programatically by looking at the `head`
(first 6 rows) like so:

```{r call_head}
head(employees)

```

**Note** that the age column has a ".." where there's a missing value (normally `NA`
in R) and the hiring date `h_date` is in a non-standard format (data people like
dates to be in `yyyy-mm-dd` format). We'll circle back to fix those issues later. 


Now, if we look at the `survey` data, we can see something troubling...
```{r call_head_survey, output.lines=6}
head(survey)
```


**Yeesh** it looks like some well-meaning but not-data-minded person went and 
stored the survey results in wide format with one column per respondant and one
row per question. 


Before we can work with this data, **We have the following problems to solve:**

1) Missing values are coded as ".." which has turned all of the numeric columns into text!
2) Dates need to be transformed before they can be used
3) Values from each person are placed in different columns
4) Variables are seperated by row, not column meaning in each row are from different variables hence the yearly column statistics are meaningless


## Fix The Data

### Fix missing values
Firstly, let's replace those ".." missing value codes with missing values (`NA`). 
We also want to convert the age column into a `numeric` type. 
Think about the logic we want to use: we want to go through the age columns of `employees` 
turn all cells with `..` into `NA`, and then convert the columns into `numeric`.

Happily, this is all rather easy, but replacing the `..`s will requie a _regular expression_ (periods are a bit tricky to deal with). _Regular expressions_ are a tricky subject, basically they're specially formatted text used to select specific formats of text. You can use _regular expression_`s to do some very complicated text manipulation - but it's more efficient to just look on <http://stackoverflow.com/questions/tagged/regex> for an existing example of something similar to what you're wanting to do.

Here, we'll use `gsub` to assign a `NA` into `employees$age` whenever 
`employees$age` is `".."` note that in the `pattern` argument, we need to write
`"\\.\\."` because in regular expressions, a dot has a special meaning so we *escape*
the dots with `\\.` to make it evaluate them as plain text. 

**The following code reads:**


* Take the `age` column from employees (accessed with `$`)


* Into that column place the output of `gsub()`

* Where `gsub` will find the pattern `"\\.\\."` and replace it with NA in `employees$age` 


```{r fix_na_gsub}
employees$age <- gsub(pattern = "\\.\\.", replacement = NA, x = employees$age)
## We could also do it like this: 
# employees$age[employees$age == ".."] <- NA
## Read as: 
## employee$age[where employees$age is equal to ".."] replace with NA
## ....but we want to teach you new tricks!
```

### Fix dates

The hiring date column (`employees$h_date`) is currently a `character` string
AKA a text variable. We'll want to make that into a proper `datetime` variable first
so that we can do interesting stuff, like work out how many years someone has been at the 
company. To do this, we'll use the base R date functions. Note that you can work with dates
in in packages like `lubridate` which just make some things a little more straightforward :)

In the following code, we need to tell R what formt the date is currently in!

The code reads:


* Overwrite the employee_data$h_date column with the output of `as.Date()`


* Within `as.Date()`, transform the existing `h_date` column


* ...And read the text as numeric month (%m) / numeric day (%d) / 4 digit year (%Y)


**Hint:** to see all available date formatting options, run `?strptime` in the console

```{r}
employees$h_date <- as.Date(employees$h_date, format = "%m/%d/%Y")
```


Now, lets work out how long they've worked here for

Read the following code as:

* Create a column in `employee_data` called `tenure`

* into that column put the result of:

* today's date (`Sys.Date()`) minus the date people were hired

* ...then divide that by ~365.25 days to give their tenure in years 

```{r}
employees$tenure <- (Sys.Date() - employees$h_date)/365.2422
```


### Reshape the scores data


## Make basic aggregations

## Use pipes to make easy aggregations

## Join the data together

## Make advanced aggregations

## Put aggregations into visuals
